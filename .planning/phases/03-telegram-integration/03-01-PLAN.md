---
phase: 03-telegram-integration
plan: 01
type: execute
---

<objective>
Connect existing n8n Telegram bot to web app with webhook endpoint for real-time meal synchronization.

Purpose: Enable users to log meals directly from Telegram (text descriptions or food photos) which get automatically synced to the web app with proper source tracking.
Output: Working webhook endpoint that receives meal data from n8n, creates meal_logs entries, and properly tracks Telegram as the source.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-meal-logging/02-05-SUMMARY.md

# Key files from Phase 2:
@app/dashboard/meals/actions.ts
@app/api/ai/analyze/route.ts
@lib/supabase/server.ts

**Tech stack available:**
- Next.js 14 App Router with API routes
- Supabase client (server-side) with RLS
- OpenRouter API for AI analysis
- Existing meal_logs table with source column

**Established patterns:**
- Server Actions for mutations (createMeal, updateMeal, deleteMeal)
- API routes for external integrations
- RLS policies enforce user ownership automatically
- Image storage in Supabase Storage with signed URLs

**Database schema (meal_logs):**
- source column: 'manual' | 'telegram_text' | 'telegram_image' | 'web' (already exists)
- All nutrition fields optional (AI fills them, webhook can pass through)
- user_id enforced by RLS policies

**n8n Integration Pattern:**
The user has an existing n8n Telegram bot workflow. The integration flow will be:
1. User sends message/photo to Telegram bot
2. n8n Telegram Trigger receives the update
3. n8n processes (optionally analyzes with AI via OpenRouter)
4. n8n sends HTTP POST to our webhook with meal data
5. Webhook creates meal_log entry for the user

**Critical constraint:**
We need to authenticate webhook requests from n8n. Options:
- Shared secret in Authorization header
- User-specific webhook tokens stored in profiles table
- Service account approach

For v1, we'll use a simple shared secret (webhook API key) that n8n includes in requests.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook API endpoint for n8n integration</name>
  <files>app/api/webhook/telegram/route.ts, .env.local</files>
  <action>
Create POST /api/webhook/telegram endpoint that:

1. **Authentication:** Verify request has correct webhook secret in Authorization header (Bearer token pattern). Secret stored as WEBHOOK_SECRET in environment variables. Return 401 if missing/incorrect.

2. **Request validation:** Accept JSON body with:
   ```typescript
   {
     user_id: string  // UUID of the user (n8n must know this - from Telegram user mapping)
     title: string
     description?: string
     meal_type?: 'breakfast' | 'lunch' | 'dinner' | 'snack'
     logged_at?: string  // ISO timestamp, default to NOW()
     photo_url?: string  // If image was uploaded to Supabase Storage by n8n
     source: 'telegram_text' | 'telegram_image'

     // Optional: AI-analyzed nutrition data (if n8n does analysis)
     calories?: number
     protein?: number
     carbs?: number
     fat?: number
     fiber?: number
     sugar?: number
     sodium?: number
     ai_confidence?: number
   }
   ```

3. **Validation:** Use Zod schema to validate. Return 400 with errors if invalid. Ensure user_id is valid UUID format.

4. **Database insertion:** Use Supabase admin client (NOT user client) to bypass RLS, but still insert with correct user_id. This is safe because webhook is authenticated. Insert meal_log with all provided fields.

5. **Response:** Return 201 with created meal object `{ id, created_at }` on success. Return appropriate error codes (400 validation, 401 auth, 500 server error).

6. **Error handling:** Wrap in try/catch, log errors server-side, return generic error messages to client (don't leak internal details).

**Critical: Use createClient from @supabase/supabase-js directly with service role key for admin access, not the @/lib/supabase/server client (which enforces RLS). Import and call `createClient(supabaseUrl, supabaseServiceKey)` within the route handler.**

**Environment variables needed:**
- WEBHOOK_SECRET (generate random 32-char string)
- NEXT_PUBLIC_SUPABASE_URL (already exists)
- SUPABASE_SERVICE_ROLE_KEY (already exists for admin access)

Add WEBHOOK_SECRET to .env.local with a secure random value.
  </action>
  <verify>
1. Endpoint exists at /api/webhook/telegram
2. Test with curl: Valid request with correct secret returns 201
3. Test with curl: Missing secret returns 401
4. Test with curl: Invalid data returns 400 with validation errors
5. Check Supabase: meal_log entry created with correct user_id and source
  </verify>
  <done>
- Webhook endpoint responds to POST requests
- Authentication via webhook secret works
- Request validation with Zod schema functions
- Meal logs created in database with proper source tracking
- Error handling returns appropriate status codes
  </done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <action>Configure n8n workflow to send data to webhook endpoint</action>
  <instructions>
I've created the webhook endpoint at /api/webhook/telegram that's ready to receive meal data.

**What I built:**
- Webhook API route with authentication (WEBHOOK_SECRET)
- Request validation for meal data
- Database insertion with source tracking
- Proper error responses

**What you need to do:**
Configure your existing n8n Telegram bot workflow to send HTTP POST requests to the webhook:

1. **Add HTTP Request node** after Telegram Trigger (and optional AI analysis)
2. **Configure endpoint:**
   - Method: POST
   - URL: `http://localhost:3000/api/webhook/telegram` (development) or `https://your-domain.com/api/webhook/telegram` (production)
3. **Set Authentication header:**
   - Header name: `Authorization`
   - Header value: `Bearer [WEBHOOK_SECRET from .env.local]`
4. **Set request body** (JSON):
   ```json
   {
     "user_id": "[your-user-id]",
     "title": "{{ $json.text || 'Meal from Telegram' }}",
     "description": "{{ $json.caption || $json.text }}",
     "meal_type": "snack",
     "source": "{{ $json.photo ? 'telegram_image' : 'telegram_text' }}",
     "photo_url": "{{ $json.photo_url }}",
     "logged_at": "{{ $now.toISO() }}"
   }
   ```

   Adjust the mapping based on your n8n workflow structure. If you're already doing AI analysis in n8n, include the nutrition fields (calories, protein, etc.).

5. **Get your user_id**: Run this SQL in Supabase SQL Editor:
   ```sql
   SELECT id FROM auth.users WHERE email = 'your-email@example.com';
   ```

6. **Test the workflow**: Send a message to your Telegram bot and verify it creates a meal entry in the web app.

**Note:** For production, you'll want to implement a user mapping mechanism (Telegram user ID → Supabase user ID) rather than hardcoding user_id. For v1/testing, hardcoded user_id is fine.
  </instructions>
  <verification>After configuration, I can verify by checking the meal_logs table for new entries with source='telegram_text' or source='telegram_image'</verification>
  <resume-signal>Type "done" when n8n workflow is configured and you've tested sending a message</resume-signal>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>End-to-end Telegram to web app meal logging integration</what-built>
  <how-to-verify>
1. **Send test message to Telegram bot:**
   - Open Telegram and message your bot with a meal description (e.g., "Grilled chicken salad with avocado")

2. **Check n8n execution:**
   - Open n8n workflow executions
   - Verify the workflow ran successfully
   - Check HTTP Request node output (should show 201 status)

3. **Verify in web app:**
   - Open the web app at http://localhost:3000/dashboard/meals
   - Confirm the meal appears in the list
   - Check that source badge shows "Telegram" (not "Manual")
   - Verify meal details match what you sent

4. **Test with image (if applicable):**
   - Send a food photo to your Telegram bot
   - Verify it appears in web app with photo_url
   - Check source shows "Telegram Image"

5. **Verify isolation:**
   - Check that only your meals appear (RLS working)
   - User_id in meal_logs matches your account
  </how-to-verify>
  <resume-signal>Type "approved" if integration works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] Webhook endpoint exists and handles POST requests
- [ ] Authentication with WEBHOOK_SECRET works (401 on invalid)
- [ ] Request validation with Zod returns 400 on invalid data
- [ ] Meals created via webhook appear in database with correct source
- [ ] n8n workflow successfully sends data to webhook
- [ ] Telegram messages create meals visible in web app
- [ ] Source tracking distinguishes telegram_text vs telegram_image
- [ ] RLS policies still enforce user data isolation
</verification>

<success_criteria>

- Webhook API endpoint created and functional
- n8n workflow configured to send meal data
- Telegram messages/images sync to web app in real-time
- Source field correctly tracks telegram_text vs telegram_image
- User data isolation via RLS maintained
- Integration tested end-to-end successfully
</success_criteria>

<output>
After completion, create `.planning/phases/03-telegram-integration/03-01-SUMMARY.md`:

# Phase 3 Plan 1: Telegram Integration Summary

**[Substantive one-liner describing what was built]**

## Accomplishments

- Webhook API endpoint for n8n integration
- n8n workflow configured for Telegram → web app sync
- Source tracking for telegram_text and telegram_image
- Real-time meal synchronization tested

## Files Created/Modified

- `app/api/webhook/telegram/route.ts` - Webhook endpoint with auth and validation
- `.env.local` - Added WEBHOOK_SECRET

## Decisions Made

[Document any decisions made during implementation]

## Issues Encountered

[Any problems and how they were resolved, or "None"]

## Next Phase Readiness

Phase 3 complete. Telegram integration working. Ready for Phase 4: Dashboard & Meals page with today's totals and filtering.
</output>
